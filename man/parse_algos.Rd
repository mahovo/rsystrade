% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parse_algos.R
\name{parse_algos}
\alias{parse_algos}
\title{Parse algos list}
\usage{
parse_algos(algos, mode = "sim")
}
\arguments{
\item{algos}{A nested list (see specification above)}

\item{mode}{\code{sim} for simulation mode or \code{live} for live trading mode.}
}
\value{
A list where each element is a list containing:
\itemize{
\item \code{instrument} An instrument name. The instrument name is also assigned
to the data frame as a comment.
\item \code{rule} A list containing one signal rule name as a character string and
optionally one stop loss rule name as a character string.
}
}
\description{
Loads data and rules into the system by parsing a list of algos.

An algo is composed of one instrument (data) and one rule (functions).

Data sets must be csv files in a single folder. The system configuration must
include a path to the data folder. Data sets are referenced by their file
names (excluding extension) as character strings.

A "rule" is a combination of one signal generating rule and one optional stop
loss rule. The stop loss rule is optional.

\code{parse_algos()} takes a nested list of algo specifications and expands it to
a list of all possible permutations of instrument names and rules. Finally
formats the list so that each element is a list containing one instrument
name and one list named \code{rule} containing one signal generating rule name
and one optional stop loss rule name.

\code{make_system()} loads the unique data sets specified in the parsed algos into
a sublist named \code{inst_data}.

Note: In the input sublists we have \code{rules} (plural, indicating one or
more), in the output sublists we have \code{rule} (singular).

Each rule in the \code{rules} list for each algo should be a function name
provided as a character string. E.g.

\if{html}{\out{<div class="sourceCode">}}\preformatted{trade_system$algos[[1]]$rules[[1]] <- list(
    "MAC(20,80)",
    "stoploss"
)
}\if{html}{\out{</div>}}

With \code{get_rule_names_by_parsed_algo()} we can parse the name of rule 1
(entry rule 1 and exit rule 1 combined) as \code{"[MA(20,80), stoploss]"}.

If for instance a moving average crossover rule is defined in the function
\code{mac(data, fast, slow)}, a (25, 100) variation should be provided to the
system as \code{entry_rule_1 <- function(x) {mac(data, 16, 64)}}. (The name
\code{entry_rule_1} is arbitrary.)

In the the \code{algos} list, instruments must be provided as a path to a csv
file. Rules must be provided as functions. (For now. Eventually the way
the \code{algos} list is parsed will depend on the mode, which can be specified
as \code{sim} for \emph{simulation mode} or \code{live} for \emph{live mode}.)

The \code{algos} parameter is a nested list in one in the following forms.
Pairs of one instrument and one rule:

\if{html}{\out{<div class="sourceCode R">}}\preformatted{algos <- list(
  list( ## algo 1: algos[[1]]
    instruments = list("instr1"),
    rules = list(rule1)
  ),
  list( ## algo 2: algos[[2]]
    instruments = list("instr2"),
    rules = list(rule2)
  )
)
}\if{html}{\out{</div>}}

Or we can apply the same rule to multiple instruments:

\if{html}{\out{<div class="sourceCode R">}}\preformatted{algos <- list(
  list( ## algo 1: algos[[1]]
    instruments = list("instr1", "instr2"),
    rules = list(rule1)
  )
)
}\if{html}{\out{</div>}}

Or multiple rules to a single instrument.:

\if{html}{\out{<div class="sourceCode R">}}\preformatted{algos <- list(
  list( ## algo 1: algos[[1]]
    instruments = list("instr1"),
    rules = list(rule1, rule2)
  )
)
}\if{html}{\out{</div>}}

In these examples \code{rule1} is the name of a list containing one signal
rule name and optionally one stop loss rule name . \code{rule2} is the name of
another list containing one signal rule name and one optional stop loss rule
name. Signal and stop loss rule names are supplied as character strings.

Subsets are then expanded to all possible permutations:

\if{html}{\out{<div class="sourceCode R">}}\preformatted{input <- list(
  list( ## algo 1: algos[[1]]
    instrument = "<inst_1_name>",
    rule = "<rule_1_name>"
  ),
  list( ## algo 2: algos[[2]]
    instrument = "<inst_2_name",
    rule = "<rule_1_name>"
  )
  list( ## algo 3: algos[[3]]
    instrument = "<inst_1_name>",
    rule = "<rule_2_name>"
  ),
  list( ## algo 4: algos[[4]]
    instrument = "<inst_2_name>",
    rule = "<rule_2_name>"
  )
)
}\if{html}{\out{</div>}}
}
